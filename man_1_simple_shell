.\" The following commands are required for all man pages.
.Dd December 28, 2019
.Dt HSH 1 SMM
.Os Ubuntu_Linux 14.04
.Sh NAME
.Nm hsh
.Nd command interpreter (simple shell)
.\" This next command is for sections 2 and 3 only.
.\" .Sh LIBRARY
.Sh SYNOPSIS
.Nm hsh
.Op file_name
.Sh DESCRIPTION
.Nm
is the standard command interpreter for the system.
The current version of
.Nm
is in the process of being changed to conform with the
.Tn POSIX
1003.2 and 1003.2a specifications for the shell (Near).
This version has many
features which make it appear similar in some respects to the Bash shell,
but it is not a Bash shell clone (see
.Xr sh 1 ) .
Only features designated by
.Tn POSIX ,
plus a few Berkeley extensions, are being incorporated into this shell (Some of them).
This man page is not intended
to be a tutorial or a complete specification of the shell
and SOME OF THE FEATURES treated in this document are
implemented and OTHERS are in progress.
.Ss Overview
The shell is a command that reads lines from either a file or the
terminal, interprets them, and generally executes other commands.
It is the program that is running when a user logs into the system
(although a user can select a different shell with the
.Xr chsh 1
command).
The shell implements a language that has flow control
constructs, a macro facility that provides a variety of features in
addition to data storage, along with built in history and line editing
capabilities.
It incorporates many features to aid interactive use and
has the advantage that the interpretative language is common to both
interactive and non-interactive use (shell scripts).
That is, commands
can be typed directly to the running shell or can be put into a file and
the file can be executed directly by the shell.
.Ss Invocation
If no args are present and if the standard input of the shell
is connected to a terminal (or if the
.Fl i
flag is set),
and the
.Fl c
option is not present, the shell is considered an interactive shell.
An interactive shell generally prompts before each command and handles
programming and command errors differently (as described below).
When first starting,
the shell inspects argument 0, and if it begins with a dash
.Sq - ,
the shell is also considered
a login shell.
This is normally done automatically by the system
when the user first logs in.
A login shell first reads commands
from the files
.Pa /etc/profile
and
.Pa .profile
if they exist.
If the environment variable
.Ev ENV
is set on entry to an interactive shell, or is set in the
.Pa .profile
of a login shell, the shell next reads
commands from the file named in
.Ev ENV .
Therefore, a user should place commands that are to be executed only at
login time in the
.Pa .profile
file, and commands that are executed for every interactive shell inside the
.Ev ENV
file.
To set the
.Ev ENV
variable to some file, place the following line in your
.Pa .profile
of your home directory
.Pp
.Dl ENV=$HOME/.shinit; export ENV
.Pp
substituting for
.Dq .shinit
any filename you wish.
.Pp
If command line arguments besides the options have been specified, then
the shell treats the first argument as the name of a file from which to
read commands (a shell script), and the remaining arguments are set as the
positional parameters of the shell ($1, $2, etc).
Otherwise, the shell
reads commands from its standard input.
.Ss Argument List Processing
All of the single letter options that have a corresponding name can be
used as an argument to the
.Fl o
option.
The set
.Fl o
name is provided next to the single letter option in
the description below.
Specifying a dash
.Dq -
turns the option on, while using a plus
.Dq +
disables the option.
The following options can be set from the command line or
with the
.Ic set
builtin (described later).
.Bl -tag -width aaaallexportfoo -offset indent
.It Fl a Em allexport
Export all variables assigned to.
.It Fl c
Read commands from the
.Ar command_string
operand instead of from the standard input.
Special parameter 0 will be set from the
.Ar command_name
operand and the positional parameters ($1, $2, etc.)
set from the remaining argument operands.
.It Fl C Em noclobber
Don't overwrite existing files with
.Dq \*[Gt] .
.It Fl e Em errexit
If not interactive, exit immediately if any untested command fails.
The exit status of a command is considered to be
explicitly tested if the command is used to control an
.Ic if ,
.Ic elif ,
.Ic while ,
or
.Ic until ;
or if the command is the left hand operand of an
.Dq &&
or
.Dq ||
operator.
.It Fl f Em noglob
Disable pathname expansion.
.It Fl n Em noexec
If not interactive, read commands but do not execute them.
This is useful for checking the syntax of shell scripts.
.It Fl u Em nounset
Write a message to standard error when attempting to expand a variable
that is not set, and if the shell is not interactive, exit immediately.
.It Fl v Em verbose
The shell writes its input to standard error as it is read.
Useful for debugging.
.It Fl x Em xtrace
Write each command to standard error (preceded by a
.Sq +\  )
before it is executed.
Useful for debugging.
.It Fl I Em ignoreeof
Ignore EOF's from input when interactive.
.It Fl i Em interactive
Force the shell to behave interactively.
.It Fl l
Make dash act as if it had been invoked as a login shell.
.It Fl m Em monitor
Turn on job control (set automatically when interactive).
.It Fl s Em stdin
Read commands from standard input (set automatically if no file arguments
are present).
This option has no effect when set after the shell has
already started running (i.e. with
.Ic set ) .
.It Fl V Em vi
Enable the built-in
.Xr vi 1
command line editor (disables
.Fl E
if it has been set).
.It Fl E Em emacs
Enable the built-in
.Xr emacs 1
command line editor (disables
.Fl V
if it has been set).
.It Fl b Em notify
Enable asynchronous notification of background job completion.
(UNIMPLEMENTED for 4.4alpha)
.El
.Ss Lexical Structure
The shell reads input in terms of lines from a file and breaks it up into
words at whitespace (blanks and tabs), and at certain sequences of
characters that are special to the shell called
.Dq operators .
There are two types of operators: control operators and redirection
operators (their meaning is discussed later).
Following is a list of operators:
.Bl -ohang -offset indent
.It "Control operators:"
.Dl &  &&  \&(  \&)  \&;  ;; | || \*[Lt]newline\*[Gt]
.It "Redirection operators:"
.Dl \*[Lt]  \*[Gt]  \*[Gt]|  \*[Lt]\*[Lt]  \*[Gt]\*[Gt]  \*[Lt]&  \*[Gt]&  \*[Lt]\*[Lt]-  \*[Lt]\*[Gt]
.El
.Ss Quoting
Quoting is used to remove the special meaning of certain characters or
words to the shell, such as operators, whitespace, or keywords.
There are three types of quoting: matched single quotes,
matched double quotes, and backslash.
.Ss Backslash
A backslash preserves the literal meaning of the following
character, with the exception of
.Aq newline .
A backslash preceding a
.Aq newline
is treated as a line continuation.
.Ss Single Quotes
Enclosing characters in single quotes preserves the literal meaning of all
the characters (except single quotes, making it impossible to put
single-quotes in a single-quoted string).
.Ss Double Quotes
Enclosing characters within double quotes preserves the literal
meaning of all characters except dollarsign
.Pq $ ,
backquote
.Pq ` ,
and backslash
.Pq \e .
The backslash inside double quotes is historically weird, and serves to
quote only the following characters:
.Dl $  `  \*q  \e  \*[Lt]newline\*[Gt] .
Otherwise it remains literal.
.Ss Reserved Words
Reserved words are words that have special meaning to the
shell and are recognized at the beginning of a line and
after a control operator.
The following are reserved words:
.Bl -column while while while while while -offset indent
.It ! Ta elif Ta fi Ta while Ta case
.It else Ta for Ta then Ta { Ta }
.It do Ta done Ta until Ta if Ta esac
.El
.Pp
Their meaning is discussed later.
.Ss Aliases
An alias is a name and corresponding value set using the
.Xr alias 1
builtin command.
Whenever a reserved word may occur (see above),
and after checking for reserved words, the shell
checks the word to see if it matches an alias.
If it does, it replaces it in the input stream with its value.
For example, if there is an alias called
.Dq lf
with the value
.Dq "ls -F" ,
then the input:
.Pp
.Dl lf foobar Aq return
.Pp
would become
.Pp
.Dl ls -F foobar Aq return
.Pp
Aliases provide a convenient way for naive users to create shorthands for
commands without having to learn how to create functions with arguments.
They can also be used to create lexically obscure code.
This use is discouraged.
.Ss Commands
The shell interprets the words it reads according to a language, the
specification of which is outside the scope of this man page (refer to the
BNF in the
.Tn POSIX
1003.2 document).
Essentially though, a line is read and if the first
word of the line (or after a control operator) is not a reserved word,
then the shell has recognized a simple command.
Otherwise, a complex
command or some other special construct may have been recognized.
.Ss Simple Commands
If a simple command has been recognized, the shell performs
the following actions:
.Bl -enum -offset indent
.It
Leading words of the form
.Dq name=value
are stripped off and assigned to the environment of the simple command.
Redirection operators and their arguments (as described below) are
stripped off and saved for processing.
.It
The remaining words are expanded as described in
the section called
.Dq Expansions ,
and the first remaining word is considered the command name and the
command is located.
The remaining words are considered the arguments of the command.
If no command name resulted, then the
.Dq name=value
variable assignments recognized in item 1 affect the current shell.
.It
Redirections are performed as described in the next section.
.El
.Ss Redirections
Redirections are used to change where a command reads its input or sends
its output.
In general, redirections open, close, or duplicate an
existing reference to a file.
The overall format used for redirection is:
.Pp
.Dl [n] Va redir-op Ar file
.Pp
where
.Va redir-op
is one of the redirection operators mentioned previously.
Following is a list of the possible redirections.
The
.Bq n
is an optional number, as in
.Sq 3
(not
.Sq Bq 3 ) ,
that refers to a file descriptor.
.Bl -tag -width aaabsfiles -offset indent
.It [n] Ns \*[Gt] file
Redirect standard output (or n) to file.
.It [n] Ns \*[Gt]| file
Same, but override the
.Fl C
option.
.It [n] Ns \*[Gt]\*[Gt] file
Append standard output (or n) to file.
.It [n] Ns \*[Lt] file
Redirect standard input (or n) from file.
.It [n1] Ns \*[Lt]& Ns n2
Duplicate standard input (or n1) from file descriptor n2.
.It [n] Ns \*[Lt]&-
Close standard input (or n).
.It [n1] Ns \*[Gt]& Ns n2
Duplicate standard output (or n1) to n2.
.It [n] Ns \*[Gt]&-
Close standard output (or n).
.It [n] Ns \*[Lt]\*[Gt] file
Open file for reading and writing on standard input (or n).
.El
.Pp
The following redirection is often called a
.Dq here-document .
.Bl -item -offset indent
.It
.Li [n]\*[Lt]\*[Lt] delimiter
.Dl here-doc-text ...
.Li delimiter
.El
.Pp
All the text on successive lines up to the delimiter is saved away and
made available to the command on standard input, or file descriptor n if
it is specified.
If the delimiter as specified on the initial line is
quoted, then the here-doc-text is treated literally, otherwise the text is
subjected to parameter expansion, command substitution, and arithmetic
expansion (as described in the section on
.Dq Expansions ) .
If the operator is
.Dq \*[Lt]\*[Lt]-
instead of
.Dq \*[Lt]\*[Lt] ,
then leading tabs in the here-doc-text are stripped.
.Ss Search and Execution
There are three types of commands: shell functions, builtin commands, and
normal programs -- and the command is searched for (by name) in that order.
They each are executed in a different way.
.Pp
When a shell function is executed, all of the shell positional parameters
(except $0, which remains unchanged) are set to the arguments of the shell
function.
The variables which are explicitly placed in the environment of
the command (by placing assignments to them before the function name) are
made local to the function and are set to the values given.
Then the command given in the function definition is executed.
The positional parameters are restored to their original values
when the command completes.
This all occurs within the current shell.
.Pp
Shell builtins are executed internally to the shell, without spawning a
new process.
.Pp
Otherwise, if the command name doesn't match a function or builtin, the
command is searched for as a normal program in the file system (as
described in the next section).
When a normal program is executed, the shell runs the program,
passing the arguments and the environment to the program.
If the program is not a normal executable file (i.e., if it does
not begin with the "magic number" whose
.Tn ASCII
representation is "#!", so
.Xr execve 2
returns
.Er ENOEXEC
then) the shell will interpret the program in a subshell.
The child shell will reinitialize itself in this case,
so that the effect will be as if a
new shell had been invoked to handle the ad-hoc shell script, except that
the location of hashed commands located in the parent shell will be
remembered by the child.
.Pp
Note that previous versions of this document and the source code itself
misleadingly and sporadically refer to a shell script without a magic
number as a "shell procedure".
.Ss Path Search
When locating a command, the shell first looks to see if it has a shell
function by that name.
Then it looks for a builtin command by that name.
If a builtin command is not found, one of two things happen:
.Bl -enum
.It
Command names containing a slash are simply executed without performing
any searches.
.It
The shell searches each entry in
.Ev PATH
in turn for the command.
The value of the
.Ev PATH
variable should be a series of entries separated by colons.
Each entry consists of a directory name.
The current directory may be indicated
implicitly by an empty directory name, or explicitly by a single period.
.El
.Ss Command Exit Status
Each command has an exit status that can influence the behaviour
of other shell commands.
The paradigm is that a command exits
with zero for normal or success, and non-zero for failure,
error, or a false indication.
The man page for each command
should indicate the various exit codes and what they mean.
Additionally, the builtin commands return exit codes, as does
an executed shell function.
.Pp
If a command consists entirely of variable assignments then the
exit status of the command is that of the last command substitution
if any, otherwise 0.
.Ss Complex Commands
Complex commands are combinations of simple commands with control
operators or reserved words, together creating a larger complex command.
More generally, a command is one of the following:
.Bl -bullet
.It
simple command
.It
pipeline
.It
list or compound-list
.It
compound command
.It
function definition
.El
.Pp
Unless otherwise stated, the exit status of a command is that of the last
simple command executed by the command.
.Ss Pipelines
A pipeline is a sequence of one or more commands separated
by the control operator |.
The standard output of all but
the last command is connected to the standard input
of the next command.
The standard output of the last
command is inherited from the shell, as usual.
.Pp
The format for a pipeline is:
.Pp
.Dl [!] command1 [ | command2 ...]
.Pp
The standard output of command1 is connected to the standard input of
command2.
The standard input, standard output, or both of a command is
considered to be assigned by the pipeline before any redirection specified
by redirection operators that are part of the command.
.Pp
If the pipeline is not in the background (discussed later), the shell
waits for all commands to complete.
.Pp
If the reserved word ! does not precede the pipeline, the exit status is
the exit status of the last command specified in the pipeline.
Otherwise, the exit status is the logical NOT of the exit status of the
last command.
That is, if the last command returns zero, the exit status
is 1; if the last command returns greater than zero, the exit status is
zero.
.Pp
Because pipeline assignment of standard input or standard output or both
takes place before redirection, it can be modified by redirection.
For example:
.Pp
.Dl $ command1 2\*[Gt]&1 | command2
.Pp
sends both the standard output and standard error of command1
to the standard input of command2.
.Pp
A ; or
.Aq newline
terminator causes the preceding AND-OR-list (described
next) to be executed sequentially; a & causes asynchronous execution of
the preceding AND-OR-list.
.Pp
Note that unlike some other shells, each process in the pipeline is a
child of the invoking shell (unless it is a shell builtin, in which case
it executes in the current shell -- but any effect it has on the
environment is wiped).
.Ss Background Commands -- &
If a command is terminated by the control operator ampersand (&), the
shell executes the command asynchronously -- that is, the shell does not
wait for the command to finish before executing the next command.
.Pp
The format for running a command in background is:
.Pp
.Dl command1 & [command2 & ...]
.Pp
If the shell is not interactive, the standard input of an asynchronous
command is set to
.Pa /dev/null .
.Ss Lists -- Generally Speaking
A list is a sequence of zero or more commands separated by newlines,
semicolons, or ampersands, and optionally terminated by one of these three
characters.
The commands in a list are executed in the order they are written.
If command is followed by an ampersand, the shell starts the
command and immediately proceed onto the next command; otherwise it waits
for the command to terminate before proceeding to the next one.
.Ss Short-Circuit List Operators
.Dq &&
and
.Dq ||
are AND-OR list operators.
.Dq &&
executes the first command, and then executes the second command iff the
exit status of the first command is zero.
.Dq ||
is similar, but executes the second command iff the exit status of the first
command is nonzero.
.Dq &&
and
.Dq ||
both have the same priority.
.Ss Flow-Control Constructs -- if, while, for, case
The syntax of the if command is
.Bd -literal -offset indent
if list
then list
[ elif list
then    list ] ...
[ else list ]
fi
.Ed
.Pp
The syntax of the while command is
.Bd -literal -offset indent
while list
do   list
done
.Ed
.Pp
The two lists are executed repeatedly while the exit status of the
first list is zero.
The until command is similar, but has the word
until in place of while, which causes it to
repeat until the exit status of the first list is zero.
.Pp
The syntax of the for command is
.Bd -literal -offset indent
for variable [ in [ word ... ] ]
do   list
done
.Ed
.Pp
The words following
.Pa in
are expanded, and then the list is executed repeatedly with the
variable set to each word in turn.
Omitting in word ... is equivalent to in "$@".
.Pp
The syntax of the break and continue command is
.Bd -literal -offset indent
break [ num ]
continue [ num ]
.Ed
.Pp
Break terminates the num innermost for or while loops.
Continue continues with the next iteration of the innermost loop.
These are implemented as builtin commands.
.Pp
The syntax of the case command is
.Bd -literal -offset indent
case word in
[(]pattern) list ;;
\&...
esac
.Ed
.Pp
The pattern can actually be one or more patterns (see
.Sx Shell Patterns
described later), separated by
.Dq \*(Ba
characters.
The
.Do
(
.Dc
character before the pattern is optional.
.Ss Grouping Commands Together
Commands may be grouped by writing either
.Pp
.Dl (list)
.Pp
or
.Pp
.Dl { list; }
.Pp
The first of these executes the commands in a subshell.
Builtin commands grouped into a (list) will not affect the current shell.
The second form does not fork another shell so is slightly more efficient.
Grouping commands together this way allows you to redirect
their output as though they were one program:
.Pp
.Bd -literal -offset indent
{ printf \*q hello \*q ; printf \*q world\\n" ; } \*[Gt] greeting
.Ed
.Pp
Note that
.Dq }
must follow a control operator (here,
.Dq \&; )
so that it is recognized as a reserved word and not as another command argument.
.Ss Functions
The syntax of a function definition is
.Pp
.Dl name ( ) command
.Pp
A function definition is an executable statement; when executed it
installs a function named name and returns an exit status of zero.
The command is normally a list enclosed between
.Dq {
and
.Dq } .
.Pp
Variables may be declared to be local to a function by using a local
command.
This should appear as the first statement of a function, and the syntax is
.Pp
.Dl local [ variable | - ] ...
.Pp
Local is implemented as a builtin command.
.Pp
When a variable is made local, it inherits the initial value and exported
and readonly flags from the variable with the same name in the surrounding
scope, if there is one.
Otherwise, the variable is initially unset.
The shell uses dynamic scoping, so that if you make the variable x local to
function f, which then calls function g, references to the variable x made
inside g will refer to the variable x declared inside f, not to the global
variable named x.
.Pp
The only special parameter that can be made local is
.Dq - .
Making
.Dq -
local any shell options that are changed via the set command inside the
function to be restored to their original values when the function
returns.
.Pp
The syntax of the return command is
.Pp
.Dl return [ exitstatus ]
.Pp
It terminates the currently executing function.
Return is implemented as a builtin command.
.Ss Variables and Parameters
The shell maintains a set of parameters.
A parameter denoted by a name is called a variable.
When starting up, the shell turns all the environment
variables into shell variables.
New variables can be set using the form
.Pp
.Dl name=value
.Pp
Variables set by the user must have a name consisting solely of
alphabetics, numerics, and underscores - the first of which must not be
numeric.
A parameter can also be denoted by a number or a special
character as explained below.
.Ss Positional Parameters
A positional parameter is a parameter denoted by a number (n \*[Gt] 0).
The shell sets these initially to the values of its command line arguments
that follow the name of the shell script.
The
.Ic set
builtin can also be used to set or reset them.
.Ss Special Parameters
A special parameter is a parameter denoted by one of the following special
characters.
The value of the parameter is listed next to its character.
.Bl -tag -width thinhyphena
.It *
Expands to the positional parameters, starting from one.
When the
expansion occurs within a double-quoted string it expands to a single
field with the value of each parameter separated by the first character of
the
.Ev IFS
variable, or by a
.Aq space
if
.Ev IFS
is unset.
.It @
Expands to the positional parameters, starting from one.
When the expansion occurs within double-quotes, each positional
parameter expands as a separate argument.
If there are no positional parameters, the
expansion of @ generates zero arguments, even when @ is
double-quoted.
What this basically means, for example, is
if $1 is
.Dq abc
and $2 is
.Dq def ghi ,
then
.Qq $@
expands to
the two arguments:
.Pp
.Sm off
.Dl \*q abc \*q \  \*q def\ ghi \*q
.Sm on
.It #
Expands to the number of positional parameters.
.It ?
Expands to the exit status of the most recent pipeline.
.It - (Hyphen.)
Expands to the current option flags (the single-letter
option names concatenated into a string) as specified on
invocation, by the set builtin command, or implicitly
by the shell.
.It $
Expands to the process ID of the invoked shell.
A subshell retains the same value of $ as its parent.
.It !
Expands to the process ID of the most recent background
command executed from the current shell.
For a pipeline, the process ID is that of the last command in the pipeline.
.It 0 (Zero.)
Expands to the name of the shell or shell script.
.El
.Ss Word Expansions
This clause describes the various expansions that are performed on words.
Not all expansions are performed on every word, as explained later.
.Pp
Tilde expansions, parameter expansions, command substitutions, arithmetic
expansions, and quote removals that occur within a single word expand to a
single field.
It is only field splitting or pathname expansion that can
create multiple fields from a single word.
The single exception to this
rule is the expansion of the special parameter @ within double-quotes, as
was described above.
.Pp
The order of word expansion is:
.Bl -enum
.It
Tilde Expansion, Parameter Expansion, Command Substitution,
Arithmetic Expansion (these all occur at the same time).
.It
Field Splitting is performed on fields
generated by step (1) unless the
.Ev IFS
variable is null.
.It
Pathname Expansion (unless set
.Fl f
is in effect).
.It
Quote Removal.
.El
.Pp
The $ character is used to introduce parameter expansion, command
substitution, or arithmetic evaluation.
.Ss Tilde Expansion (substituting a user's home directory)
A word beginning with an unquoted tilde character (~) is
subjected to tilde expansion.
All the characters up to
a slash (/) or the end of the word are treated as a username
and are replaced with the user's home directory.
If the username is missing (as in
.Pa ~/foobar ) ,
the tilde is replaced with the value of the
.Va HOME
variable (the current user's home directory).
.Ss Parameter Expansion
.\" ============================================================================================
.\" The following commands should be uncommented and
.\" used where appropriate.
.\" .Sh IMPLEMENTATION NOTES
.\" This next command is for sections 2, 3, and 9 only
.\"     (function return values).
.\" .Sh RETURN VALUES
.\" This next command is for sections 1, 6, 7, and 8 only.
.\" .Sh ENVIRONMENT
.\" .Sh FILES
.\" This next command is for sections 1, 6, and 8 only
.\"     (command return values to the shell).
.\" .Sh EXIT STATUS
.\" .Sh EXAMPLES
.\" This next command is for sections 1, 4, 6, 7, 8, and 9 only
.\"     (fprintf/stderr type diagnostics).
.\" .Sh DIAGNOSTICS
.\" .Sh COMPATIBILITY
.\" This next command is for sections 2, 3, 4, and 9 only
.\"     (settings of the errno variable).
.\" .Sh ERRORS
.\" .Sh SEE ALSO
.\" .Sh STANDARDS
.\" .Sh HISTORY
.\" .Sh AUTHORS
.\" .Sh CAVEATS
.\" .Sh BUGS
